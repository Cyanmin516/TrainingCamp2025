# 路由OSPF
- speacher: pro. Chen
- date: 2025-9-26
- class 17
- CCNA3 企業網路、資安與自動化

#實務上 #OSPF #router-id #wildcard-mask #萬用遮罩 #show_ip_protocols #show_ip_route #################01

## 實務上
那些封包可以對應設備
switch : 生成樹，BPDU
router : 動帶路由 OSPF

路由器 DR : 選效能高, 頻寬大

## OSPF
OSPF 開放式最短路徑優先: OSPFv2對應IPv4, OSPFv3對應IPv6

鏈路狀態路由協定: OSPF, ISIS, 需要更多的運算資源，會知道整體網路，但收斂速度更快，適合更大型網路。
向量路由資訊協定: RIP, iGRP

RIP 上限15個HOP，不適合大型企業。


**路由協定訊息**
- Type1 : Hello封包
- Type2 : 資料庫描述封包DBD
- Type3 : 鏈路狀態醒求封包LSR
- Type4 : 鏈路狀態更新封包LSU
- Type5 : 鏈路狀態確認封包LSAck

```bash
鄰居表
show ip ospf neighbor

鏈路狀態資料庫
show ip ospf database

轉發資料庫
show ip route
```

**SPF演算法**
成本最小路徑

單區域OSPF : 全部都同一區
多區域OSPF : 有骨幹線路，A-B-C區域，B區只有一條通道，減少計算量

鄰居表,拓樸表,路由表


### 1.2.4 Hello 封包

OSPF type1 hello:
- 發現OSPF鄰居
- 兩部路由器參數要一致，hello與dead間隔
- 乙太網路等*多重存取*選定指定路由器(DR)，和備用指定路由器(BDR)。點對點不需要DR或BDR。

比較生成樹BPDU
- 優先權，最小優先
- ID，MAC位址，最小優先

convergence 收斂
行為
- 停用
- 起始
- HELLO, OSPF-多播224.0.0.5
- 回應單點
- 建立
- 選舉DR和BDR
    - 優先權，最小優先
    - 看ID，最小優先

每次傳訊都會回應LSAck

- LSA泛洪 : 連接數量= N*(N-1)/2，級數增加

- DR只用於LSA發布，轉送所有其他封包

總結優先順序：
1. 手動設定的 router-id
2. **最高IP** 的 Loopback 介面
3. **最高IP** 的實體介面

## 2 OSPF 路由器ID

```bash
router ospf <process-id>
router ospf 10 
R2(config-router)#?
```
why OSPF router-ID
- 32-bits
- OSPF資料庫的同步
- 餐與選舉指定路由器(DR)




迴路介面
```sh
指定介面
R1(config-if)# interface loopback 1
R1(config-if)# ip address 1.1.1.1 255.255.255.255
end
```

設定ID
```bash
路由process-id，管理不同網路區域
router ospf 10
路由器之間手動設定ID
R1(config-router)# router-id 1.1.1.1
```

修改路由器ID
OSPF不允許變更路由器ID，直到*重新載OSPF服務*

修改ID
```bash
R1(config)# router ospf 10
R1(config-router)# router-id 1.1.1.1
R1# clear ip ospf process
[y]
reboot OSPF service
R1# show ip protocols
```

### 2.2.1 network 指令

使用 OSPF 的網路類型之一是點對點網路。你可以透過設定 **network** 命令來指定屬於**點對點**網路的介面。

R1(config-router)# network <network-address> <wildcard-mask> area <area-id>

**萬用遮罩** wildcard-mask : 與子網路遮罩反向，遮罩0匹配對應位元值，遮罩1忽略匹配對應位元值。

tips: 子網路遮罩最後位多為0或偶數，萬用遮罩最後位常是奇數。



#### 2.2.5練習
```bash
router ospf 10
router-id 2.2.2.2
network 10.1.1.14 0.0.0.0 area 0
network 10.3.3.5 0.0.0.0 area 0
network 10.1.4.11 0.0.0.0 area 0
```
這組命令的作用是：在`程序編號 10` 的 OSPF 路由器上，手動將其 Router ID 設定為 `2.2.2.2`。然後，它會找到三個 IP 位址分別為 `10.1.1.14`、`10.3.3.5` 和 `10.1.4.11` 的介面，並將這三個介面都納入 `OSPF 0` 區域中，讓它們開始發送和接收 OSPF 封包。


#### 2.2.6 ip ospf命令設定
進入介面設定OSPF
R1(config-if)# ip ospf <process-id> area <area-id>

```bash
R1(config)# interface lo0
R1(config-if)# ip ospf 10 area 0
```

interface lo0= interface lookback 0


#### 2.2.8被動介面
對終端浪費資源，也有資安風險。
1. 無效頻寬
2. 無效資源
3. 資安風險

```bash
R1(config)# router ospf 10
R1(config-router)# passive-interface loopback 0
R1# show ip protocols
```

練習2.2.10 
```bash
R1(config)# router ospf 10
設定lo0為被動
R2(config-router)#passive-interface lo0
預設把介面設定為被動，對特定開放
R1(config-router)# passive-interface default
R1(config-router)# no passive-interface g0/0/0
R1(config-router)# no passive-interface g0/0/1
R1# show ip protocols
```

#### 2.2.12 OSPF點對點網路
點對點不需要DR，互相通告。

更改
```bash
設定為虛擬網段
R(config-if)# interface lookback 0
R(config)# ip ospf network point-to-point
```


#### 2.2.13 sample 
設定OSPF
```bash
R(config)# router ospf 10
R(config-router)# router-id 1.1.1.1

do show ip route
C 10.1.1.4/30
L 10.1.1.6/32

指定網段
R1(config-router)# netwrok 10.1.1.4 0.0.0.3 area 0
指定IP
R2(config-router)# network 10.1.1.6 0.0.0.0 area 0
指定介面
R3(config)# interface g0/0/0
R3(config-if)# ip ospf 10 area 0
關閉末端的OSPF
R(config-router)# no passive-interface g0/0/0
show ip protocols
show ip route
O IP/mask [110/128] ...
```


### 2.3 多重存取網路
- 路由器 DR : 選效能高, 頻寬大
- LSA先傳送給DR與BDR

```bash
show ip ospf interface g0/0/0
show ip ospf neighbor
```

選DR/BDR
優先序(0-255)選最高的，預設1，相同優先時選IP最高者

DR選舉，不是搶占資源，下列原因重選。
- DR故障
- DR的OSPF故障或停止
- DR介面DOWN

#### 2.3.9 OSPF 優先順序設定
重新設定DR
```bash
R1(config)# interface G0/0/0
R1(config-if)# ip ospf priority 255

R2(config)# interface G0/0/0
R2(config-if)# ip ospf priority 0

R3(config)# interface G0/0/0
R3(config-if)# ip ospf priority 100

R1# clear ip ospf process
[no]:y
R2# clear ip ospf process
[no]:y
R3# clear ip ospf process
[no]:y
```

#### 2.3.11 BR與BDR
```bash
RA# debug ip ospf adj
RB# debug ip ospf adj

show ip ospf interface g0/0
hello 10, dead 40
等30秒dead time is expired

等50秒路由器重啟
undebug all
```
### 2.4.1 OSPF成本度量值
COST=10^8/頻寬
100M/頻寬
只有整數
- auto-cost reference-bandwidth
- ip ospf cost
- auto-cost reference-bandwidth <Mbps>

auto-cost reference-bandwidth 10000
= 10G最高速

#### 2.4.4
interface g0/0/1
ip ospf cost 30
interface lo0
ip ospf cost 10


最好統一設定測量值

#### 2.4.6 practice
```bash
Router(config-router)# auto-cost reference-bandwidth <defautl_100_Mbps>
R1(config)# interface g0/0/1
R1(config-if)# ip ospf cost 30
R1(config-if)# interface lo0
R1(config-if)# ip ospf cost 10
R1# show ip route ospf
```

#### 2.4.7 Hello封包間隔
乙太網路 : hello 10s, dead 40s
鄰居之間要有相同的hello參數
dead = time x 4
修改
```sh
R1(config)# interface g0/0/0
R1(config-if)# ip ospf hello-interval 5
R1(config-if)# ip ospf dead-interval 20

modify immediatety
```

### 2.5 OSPFv2(IPv4)傳播預設靜態路由
邊際路由設定
1. 手動設定靜態預設路由
2. 透過OSPF宣告
```sh
R2(config)# ip route 0.0.0.0 0.0.0.0 s0.0.0
R2(config)# router ospf 1
R2(config-router)# default-information originate

檢查
R2# show ip route 
S*   0.0.0.0/0 is directly connected, Serial0/1/0
R1# show ip route 
O*E2 0.0.0.0/0 [110/1] via 172.16.3.2, 00:01:46, Serial0/0/0
```

### 2.6 驗證 OSPF
- 網段不同大小
- Hello 間隔不同
- 錯誤設定成被動模式
- 網路類型不匹配 broadcast,point-to-point

show ip ospf interface <g0/0>
supress hello address
壓制hello備援路由

show ip ospf interface brief

```sh
show ip interface brief
show ip route
show ip route ospf
show ip ospf neighbor
show ip protocols
show ip ospf interface brief
show ip ospf interface g0/0/0
```












## Gemini

讓 Loopback 介面（lo0）加入 OSPF，主要有兩個非常重要的原因：

### 1. 確保路由穩定性與高可用性

**Loopback 介面**就像路由器的「**身分證**」。它不像實體介面那樣，可能會因為線路故障或硬體損壞而斷線。

當你將 lo0 介面的 IP 位址宣告到 OSPF 協定中，這個 IP 位址就會被廣播到整個網路。即使路由器所有的實體介面都斷線了，只要 lo0 介面還能透過其他備援路徑被存取，其他路由器還是能找到它，並保持 OSPF 鄰居關係的穩定性。

這對於一些需要穩定 IP 位址的應用場景至關重要，例如：
* **遠端管理**：即使實體介面故障，你仍然可以透過 lo0 的 IP 位址來遠端連線到路由器進行故障排除。
* **BGP 協定**：在 BGP 中，通常會使用 Loopback 介面的 IP 作為建立鄰居關係的來源（Source），以確保 BGP Session 不會因為實體介面斷線而中斷。

---

### 2. 避免路由重新計算

當 OSPF 宣告一個**實體介面**時，它會將該介面的 IP 位址與 OSPF 的 **Router ID** 綁定。但如果這個實體介面斷線了，OSPF 就會觸發整個網路的 **Router ID 重新選舉**，並重新計算路由，這會導致網路短暫的震盪。

相反地，如果你將 **lo0 介面的 IP 位址**作為 OSPF 的 Router ID，因為 lo0 永遠不會斷線，它就能提供一個 **永不改變的 Router ID**。這可以避免因為實體介面斷線而導致的 Router ID 重新選舉，進而減少不必要的路由計算，讓網路更加穩定。

**總結來說**，讓 lo0 介面加入 OSPF 是為了確保路由器的身分（Router ID）和主要服務的 IP 位址（如遠端管理或 BGP Session）具有最高的**穩定性與高可用性**，避免因為實體介面的故障而影響整個網路的運作。

**lo0** 是 **Loopback 介面**的簡稱，它在路由器或網路設備上扮演著一個非常重要的角色。你可以把它想像成一個**永不關閉的虛擬網路介面**。

---

### lo0 的主要作用

#### 1. 提供一個穩定的設備身份
lo0 介面通常會被設定一個穩定的 IP 位址。這個 IP 位址就像是路由器的「身分證」，它不與任何實體網路介面（例如乙太網路埠）綁定。

* **穩定的 IP 位址**：即使路由器所有的實體介面都斷線了，lo0 介面仍然存在，它的 IP 位址也不會改變。這對於遠端管理（例如使用 SSH 連線）非常有用，因為你可以永遠透過這個 IP 位址來存取路由器。
* **路由協定的唯一識別**：在許多路由協定中，尤其是 **OSPF** 和 **BGP**，會使用 lo0 的 IP 位址作為路由器的唯一識別碼（**Router ID**）。由於 lo0 介面永遠不會斷線，可以確保這個識別碼的穩定性，避免因實體介面斷線而導致路由協定重新計算，從而保持網路的穩定。

---

#### 2. 作為服務的來源位址
許多網路服務，如 BGP 協定，會選擇 lo0 介面的 IP 位址作為封包的**來源位址 (Source Address)**。

* **避免連線中斷**：當你在路由器之間建立 BGP 鄰居關係時，如果使用實體介面的 IP，一旦這條路徑上的實體介面斷線，BGP 連線就會中斷。但如果使用 lo0 介面的 IP 位址，只要路由器之間還有其他備援路徑可以連通，BGP 鄰居關係就不會受到影響，可以大幅提高網路的彈性與可靠性。

---

#### 3. 測試與故障排除
lo0 介面是一個非常理想的測試工具。

* **內部連線測試**：你可以使用 `ping` 指令來測試 lo0 介面的 IP 位址，這可以用來確認路由器內部的 TCP/IP 堆疊是否正常運作。
* **服務可達性測試**：如果路由器上運行著某些服務（例如 DHCP 或 DNS），你可以從內部使用 lo0 的 IP 來測試這些服務是否正常運作，這比直接在外部測試更為可靠。


### Q:interface lo0有綁定實體介面嗎

沒有，**interface lo0 (Loopback 介面)** 是個虛擬介面，它**不與任何實體介面綁定**。

這就是它最重要的特性，也是它在網路中如此重要的原因。

### 為什麼不綁定實體介面？

* **永不關閉**：Loopback 介面不依賴於任何實體線路。無論你的實體網路線路斷了多少條，lo0 介面永遠處於「**up**」的狀態。
* **獨立的 IP 位址**：你可以在 lo0 上設定一個 IP 位址，這個位址不會因為其他實體介面的啟用或關閉而受影響。
* **穩定的身份**：因為它永遠在線，這個 IP 位址就成了路由器的穩定身份，適合用來作為路由協定（如 OSPF 或 BGP）中的 **Router ID** 或遠端管理的目標位址。

總結來說，lo0 的價值就在於它與實體世界完全獨立，提供了一個穩定的、可靠的、永不中斷的虛擬介面。









